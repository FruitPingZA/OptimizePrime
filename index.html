<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OptimizePrime</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />

  <!-- Load AVIF encoder via CDN (browser-native, no build needed) -->
  <script type="module">
    import { encode } from 'https://unpkg.com/@jsquash/avif@1.1.1?module';
    window.avifEncode = encode;
  </script>
</head>
<body>
  <div class="container">
    <h1>OptimizePrime</h1>

    <div class="drop-area" id="dropArea">
      <p>
        Drag & drop images here or
        <label for="fileInput" class="upload-label">browse</label>
      </p>
      <input type="file" id="fileInput" accept="image/*" multiple hidden />
    </div>

    <div class="controls">
      <label>Max Width: <input type="number" id="maxWidth" value="800" /></label>
      <label>Max Height: <input type="number" id="maxHeight" value="800" /></label>
      <label>
        Format:
        <select id="format">
          <option value="webp">WebP</option>
          <option value="avif">AVIF</option>
          <option value="jpeg">JPEG</option>
          <option value="jpg">JPG</option>
          <option value="png">PNG</option>
        </select>
      </label>
      <label>
        Target Size (KB): <input type="number" id="targetSize" value="200" />
      </label>
      <br />
      <button id="processBtn">Compress</button>
      <button id="downloadAllBtn">Download</button>
    </div>

    <div id="preview"></div>
  </div>

  <!-- Dependency Libraries -->
  <script src="lib/jszip.min.js"></script>
  <script src="lib/FileSaver.min.js"></script>

  <!-- Image Compression Logic -->
  <script src="utils/imageProcessor.js"></script>
  <script>
    let processedBlobs = [];
    let originalPreviews = [];

    const fileInput = document.getElementById("fileInput");
    const processBtn = document.getElementById("processBtn");
    const downloadAllBtn = document.getElementById("downloadAllBtn");
    const dropArea = document.getElementById("dropArea");
    const preview = document.getElementById("preview");

    fileInput.addEventListener("change", handleFiles);
    processBtn.addEventListener("click", processImages);
    downloadAllBtn.addEventListener("click", downloadAll);

    dropArea.addEventListener("dragover", (e) => e.preventDefault());
    dropArea.addEventListener("drop", (e) => {
      e.preventDefault();
      handleFiles({ target: { files: e.dataTransfer.files } });
    });
    dropArea.addEventListener("click", () => fileInput.click());

    let filesToProcess = [];

    function handleFiles(event) {
      filesToProcess = Array.from(event.target.files);
      preview.innerHTML = "";
      processedBlobs = [];
      originalPreviews = [];

      filesToProcess.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const container = document.createElement("div");
          container.className = "image-container";

          const originalImg = new Image();
          originalImg.src = e.target.result;
          originalImg.className = "preview-img";

          const label = document.createElement("p");
          label.innerText = file.name;

          container.appendChild(label);
          container.appendChild(originalImg);
          preview.appendChild(container);

          originalPreviews.push({ index, file, element: container });
        };
        reader.readAsDataURL(file);
      });

      fileInput.value = ""; // Allow same file to be reselected
    }

    async function processImages() {
      const maxWidth = parseInt(document.getElementById("maxWidth").value);
      const maxHeight = parseInt(document.getElementById("maxHeight").value);
      const format = document.getElementById("format").value;
      const targetSize = parseInt(document.getElementById("targetSize").value) * 1024;
      processedBlobs = [];

      for (const { file, element } of originalPreviews) {
        const { blob, previewURL, name } = await compressImage(file, format, maxWidth, maxHeight, targetSize);

        const compressedImg = new Image();
        compressedImg.src = previewURL;
        compressedImg.className = "preview-img compressed";

        element.appendChild(compressedImg);
        processedBlobs.push({ blob, name });
      }
    }

    async function downloadAll() {
      if (!processedBlobs.length) {
        alert("No images to download.");
        return;
      }

      const isZip = processedBlobs.length > 10;

      if (isZip) {
        const zip = new JSZip();
        processedBlobs.forEach(({ blob, name }) => {
          zip.file(name, blob);
        });
        const zipBlob = await zip.generateAsync({ type: "blob" });
        saveAs(zipBlob, "optimizeprime_images.zip");
        setTimeout(clearPreview, 1000);
      } else {
        for (const { blob, name } of processedBlobs) {
          saveAs(blob, name);
          await new Promise((res) => setTimeout(res, 300));
        }
        setTimeout(clearPreview, 1000);
      }
    }

    function clearPreview() {
      preview.innerHTML = "";
      processedBlobs = [];
      originalPreviews = [];
      filesToProcess = [];
    }
  </script>
</body>
</html>
