<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OptimizePrime</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="container">
    <h1>OptimizePrime</h1>
    <div class="drop-area" id="dropArea">
      <p>Drag & drop images or <label for="fileInput" class="upload-label">browse</label></p>
      <input type="file" id="fileInput" accept="image/*" multiple hidden />
    </div>

    <div class="controls">
      <label>Max Width: <input type="number" id="maxWidth" value="800" /></label>
      <label>Max Height: <input type="number" id="maxHeight" value="800" /></label>
      <label>Format:
        <select id="format">
          <option value="avif">AVIF</option>
          <option value="webp">WebP</option>
          <option value="jpeg">JPEG</option>
          <option value="png">PNG</option>
        </select>
      </label>
      <label>Target Size (KB): <input type="number" id="targetSize" value="200" /></label>
      <button id="processBtn">Compress</button>
      <button id="downloadAllBtn">Download</button>
    </div>

    <div id="preview"></div>
  </div>

  <script src="lib/jszip.min.js"></script>
  <script src="lib/FileSaver.min.js"></script>

  <script type="module">
    import { AvifEncoder } from 'https://cdn.jsdelivr.net/npm/@jsquash/avif@0.4.2/+esm';

    const fileInput = document.getElementById("fileInput");
    const dropArea = document.getElementById("dropArea");
    const preview = document.getElementById("preview");
    const processBtn = document.getElementById("processBtn");
    const downloadAllBtn = document.getElementById("downloadAllBtn");

    let originalFiles = [];
    let processedBlobs = [];

    window.encodeAvifFromCanvas = async function(canvas, quality = 70) {
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      const encoder = new AvifEncoder();
      encoder.configure({
        cqLevel: Math.floor((100 - quality) * 0.63),
        tileRowsLog2: 0,
        tileColsLog2: 0
      });

      encoder.encode(imageData);
      const avifBuffer = encoder.flush();
      encoder.close();

      return new Blob([avifBuffer], { type: 'image/avif' });
    };

    function loadImageFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = reader.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function compressImage(file, format, maxWidth, maxHeight, targetSize) {
      const img = await loadImageFromFile(file);
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      let quality = 0.95;
      let blob;

      if (format === "avif") {
        do {
          blob = await window.encodeAvifFromCanvas(canvas, quality * 100);
          quality -= 0.05;
        } while (blob.size > targetSize && quality > 0.05);
      } else {
        do {
          blob = await new Promise(res => canvas.toBlob(res, `image/${format}`, quality));
          quality -= 0.05;
        } while (blob.size > targetSize && quality > 0.05);
      }

      return {
        blob,
        previewURL: URL.createObjectURL(blob),
        name: file.name.replace(/\.[^/.]+$/, `.${format}`)
      };
    }

    function handleFiles(fileList) {
      preview.innerHTML = "";
      processedBlobs = [];
      originalFiles = Array.from(fileList);

      originalFiles.forEach(file => {
        const container = document.createElement("div");
        container.className = "image-container";

        const reader = new FileReader();
        reader.onload = e => {
          const originalImg = new Image();
          originalImg.className = "preview-img";
          originalImg.src = e.target.result;

          const label = document.createElement("p");
          label.innerText = file.name;

          container.appendChild(label);
          container.appendChild(originalImg);
          preview.appendChild(container);
        };
        reader.readAsDataURL(file);
      });

      fileInput.value = "";
    }

    dropArea.addEventListener("click", () => fileInput.click());
    dropArea.addEventListener("dragover", e => e.preventDefault());
    dropArea.addEventListener("drop", e => {
      e.preventDefault();
      handleFiles(e.dataTransfer.files);
    });
    fileInput.addEventListener("change", () => handleFiles(fileInput.files));

    processBtn.addEventListener("click", async () => {
      const format = document.getElementById("format").value;
      const maxWidth = parseInt(document.getElementById("maxWidth").value);
      const maxHeight = parseInt(document.getElementById("maxHeight").value);
      const targetSize = parseInt(document.getElementById("targetSize").value) * 1024;

      processedBlobs = [];

      const containers = Array.from(preview.querySelectorAll(".image-container"));
      for (let i = 0; i < originalFiles.length; i++) {
        const file = originalFiles[i];
        const container = containers[i];

        try {
          const { blob, previewURL, name } = await compressImage(file, format, maxWidth, maxHeight, targetSize);

          const compressedImg = new Image();
          compressedImg.className = "preview-img compressed";
          compressedImg.src = previewURL;

          container.appendChild(compressedImg);
          processedBlobs.push({ blob, name });
        } catch (err) {
          console.error(`Error compressing ${file.name}:`, err);
        }
      }
    });

    downloadAllBtn.addEventListener("click", async () => {
      if (!processedBlobs.length) return alert("No images to download.");

      if (processedBlobs.length > 10) {
        const zip = new JSZip();
        processedBlobs.forEach(({ blob, name }) => zip.file(name, blob));
        const zipBlob = await zip.generateAsync({ type: "blob" });
        saveAs(zipBlob, "optimizeprime.zip");
      } else {
        for (const { blob, name } of processedBlobs) {
          saveAs(blob, name);
          await new Promise(res => setTimeout(res, 100));
        }
      }

      setTimeout(() => {
        preview.innerHTML = "";
        processedBlobs = [];
        originalFiles = [];
      }, 1000);
    });
  </script>
</body>
</html>
